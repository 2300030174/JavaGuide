---
title: Detailed Explanation of Class File Structure
category: Java
tag:
  - JVM
---

## A Review of Bytecode

In Java, the code that the JVM can understand is called `bytecode` (i.e., files with the `.class` extension). It is not targeted at any specific processor but rather at the virtual machine. The Java language, through bytecode, addresses the low execution efficiency problem of traditional interpreted languages to some extent while retaining the portability characteristic of interpreted languages. Therefore, Java programs run efficiently, and since bytecode is not targeted at a specific machine, Java programs can run on various operating systems without recompilation.

Languages such as Clojure (a dialect of Lisp), Groovy, Scala, JRuby, and Kotlin run on the Java Virtual Machine. The following diagram shows how different languages are compiled into `.class` files by different compilers and ultimately run on the Java Virtual Machine. The binary format of `.class` files can be viewed using [WinHex](https://www.x-ways.net/winhex/).

![Programming Languages Running on the Java Virtual Machine](https://oss.javaguide.cn/github/javaguide/java/basis/java-virtual-machine-program-language-os.png)

It can be said that `.class` files are an important bridge between different languages on the Java Virtual Machine and are also a significant reason supporting Java's cross-platform capabilities.

## Summary of Class File Structure

According to the Java Virtual Machine Specification, a Class file is defined by `ClassFile`, which is somewhat similar to a structure in C.

The structure of `ClassFile` is as follows:

```java
ClassFile {
    u4             magic; // Signature of the Class file
    u2             minor_version; // Minor version number of the Class
    u2             major_version; // Major version number of the Class
    u2             constant_pool_count; // Number of constants in the pool
    cp_info        constant_pool[constant_pool_count-1]; // Constant pool
    u2             access_flags; // Access flags of the Class
    u2             this_class; // Current class
    u2             super_class; // Parent class
    u2             interfaces_count; // Number of interfaces
    u2             interfaces[interfaces_count]; // A class can implement multiple interfaces
    u2             fields_count; // Number of fields
    field_info     fields[fields_count]; // A class can have multiple fields
    u2             methods_count; // Number of methods
    method_info    methods[methods_count]; // A class can have multiple methods
    u2             attributes_count; // Number of attributes in this class's attribute table
    attribute_info attributes[attributes_count]; // Collection of attributes
}
```

By analyzing the contents of `ClassFile`, we can understand the composition of a class file.

![ClassFile Content Analysis](https://oss.javaguide.cn/java-guide-blog/16d5ec47609818fc.jpeg)

The following image is viewed through the IDEA plugin `jclasslib`, allowing you to see the Class file structure more intuitively.

![](https://oss.javaguide.cn/java-guide-blog/image-20210401170711475.png)

Using `jclasslib`, you can not only visually inspect the bytecode file corresponding to a class but also view basic information about the class, constant pool, interfaces, attributes, functions, and more.

Below are detailed introductions to some components involved in the Class file structure.

### Magic Number

```java
    u4             magic; // Signature of the Class file
```

The first 4 bytes of each Class file are called the magic number, and its sole purpose is to **determine whether this file is a Class file that can be accepted by the virtual machine**. The Java specification defines the magic number as a fixed value: 0xCAFEBABE. If the read file does not start with this magic number, the Java Virtual Machine will refuse to load it.

### Class File Version Number (Minor & Major Version)

```java
    u2             minor_version; // Minor version number of the Class
    u2             major_version; // Major version number of the Class
```

Immediately following the magic number are the version numbers of the Class file: the 5th and 6th bytes are the **minor version number**, and the 7th and 8th bytes are the **major version number**.

Each time a major version of Java is released (e.g., Java 8, Java 9), the major version number increases by 1. You can quickly check the version number information of a Class file using the `javap -v` command.

Higher versions of the Java Virtual Machine can execute Class files generated by lower version compilers, but lower versions of the Java Virtual Machine cannot execute Class files generated by higher version compilers. Therefore, in actual development, we must ensure that the JDK version used for development is consistent
